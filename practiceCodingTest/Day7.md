### 문제🧐
사진들을 보며 추억에 젖어 있던 루는 사진별로 추억 점수를 매길려고 합니다. 사진 속에 나오는 인물의 그리움 점수를 모두 합산한 값이 해당 사진의 추억 점수가 됩니다.  
예를 들어 사진 속 인물의 이름이 ["may", "kein", "kain"]이고 각 인물의 그리움 점수가 [5점, 10점, 1점]일 때 해당 사진의 추억 점수는 16(5 + 10 + 1)점이 됩니다.  
다른 사진 속 인물의 이름이 ["kali", "mari", "don", "tony"]이고 ["kali", "mari", "don"]의 그리움 점수가 각각 [11점, 1점, 55점]]이고, "tony"는 그리움 점수가 없을 때, 이 사진의 추억 점수는 3명의 그리움 점수를 합한 67(11 + 1 + 55)점입니다.  
그리워하는 사람의 이름을 담은 문자열 배열 name, 각 사람별 그리움 점수를 담은 정수 배열 yearning, 각 사진에 찍힌 인물의 이름을 담은 이차원 문자열 배열 photo가 매개변수로 주어질 때, 사진들의 추억 점수를 photo에 주어진 순서대로 배열에 담아 return하는 solution 함수를 완성해주세요.

[입출력 예]  
`name ["may", "kein", "kain", "radi"]`  
`yearning [5, 10, 1, 3]`  
`photo [["may", "kein", "kain", "radi"],["may", "kein", "brin", "deny"], ["kon", "kain", "may", "coni"]]`  
`result [19, 15, 6]`

### 문제 풀이 전략🌈
- 데이터 매핑
  - name과 yearning을 기반으로, 그리움 점수를 쉽게 조회할 수 있는 Map을 생성
  - 이렇게 하면 각 사진에 등장하는 인물의 그리움 점수를 효율적으로 계산할 수 있음
- 사진별 추억 점수 계산
  - photo 배열을 순회하면서, 각 사진에 등장하는 인물의 그리움 점수를 합산하여 추억 점수를 계산
  - 각 사진에 대한 추억 점수를 List나 배열에 저장
- 최종적으로 각 사진에 대한 추억 점수를 담은 배열을 반환

```ruby
public class Solution {
    public int[] solution(String[] name, int[] yearning, String[][] photo) {
        // 1. 그리움 점수를 저장할 Map 생성 -> O(k)
        // 이 Map을 통해 인물의 이름을 통해 바로 그리움 점수를 조회할 수 있다.
        Map<String, Integer> yearningMap = new HashMap<>();
        for (int i = 0; i < name.length; i++) {
            yearningMap.put(name[i], yearning[i]);
        }

        // 2. 사진별 추억 점수를 계산 -> O(n * m)
        // photo 배열을 순회하면서 각 사진의 인물들의 이름을 조회하고, yearningMap에서 그리움 점수를 얻는다.
        // getOrDefault를 사용하여 인물의 이름이 Map에 없을 경우, 점수를 0으로 처리
        int[] result = new int[photo.length];
        for (int i = 0; i < photo.length; i++) {
            int totalScore = 0;
            for (String person : photo[i]) {
                totalScore += yearningMap.getOrDefault(person, 0);
            }
            result[i] = totalScore;
        }

        // 3. 결과 배열 반환
        return result;
    }
}

```

### 여기서 사용된 알고리즘‼️
- `시간 복잡도`
  - O(n * m) 시간 복잡도를 사용
- 시간 복잡도란?
  - 알고리즘이 입력 크기(Input Size)에 따라 실행하는 데 걸리는 시간을 나타내는 척도이다.
  - 쉽게 말해서, 특정 알고리즘이 얼마나 빠르게 실행되는지를 평가하는 방법이다.
- 시간 복잡도의 목적
  - 시간 복잡도는 알고리즘의 효율성을 평가하는 중요한 기준 중 하나이다.
  - 코드를 실행하기 전에, 이 코드가 대략적으로 얼마나 많은 연산을 수행할지, 특히 입력 데이터의 크기가 커질 때 어떻게 성능이 변할지를 예측하는 데 사용된다.
- 시간 복잡도는 주로 빅-오 표기법을 사용

### Big-O 표기법의 종류
- O(1): 상수 시간 복잡도
  - 입력 크기에 관계없이 항상 일정한 시간이 걸립니다.
  - 예: 배열의 특정 요소에 접근하기
- O(n): 선형 시간 복잡도
  - 입력 크기에 비례하여 시간이 걸립니다. 입력 크기가 커질수록 수행 시간이 비례적으로 증가합니다.
  - 예: 배열의 모든 요소를 하나씩 탐색하기
- O(n^2): 이차 시간 복잡도
  - 입력 크기에 제곱에 비례하여 시간이 걸립니다.
  -  일반적으로 중첩된 반복문에서 발생합니다.
  - 예: 이중 for문으로 배열의 모든 쌍을 비교하기
- O(log n): 로그 시간 복잡도
  - 입력 크기가 커질수록 시간이 느리게 증가합니다.
  - 보통 이진 탐색에서 발생합니다.
  - 예: 이진 탐색 알고리즘
- O(n log n): 선형 로그 시간 복잡도
  - 입력 크기에 로그를 곱한 만큼의 시간이 걸립니다.
  - 병합 정렬이나 퀵 정렬과 같은 효율적인 정렬 알고리즘에서 나타납니다.
  - 예: 병합 정렬, 퀵 정렬
- O(2^n): 지수 시간 복잡도
  - 입력 크기에 비례하여 지수적으로 시간이 증가합니다.
  - 입력 크기가 조금만 커져도 매우 큰 시간이 걸리게 됩니다.
  - 예: 재귀적인 피보나치 수열 계산


### 사용된 시간 복잡도 분석📈
- Map 생성 단계
  - name 배열과 yearning 배열을 HashMap에 저장하는 작업은 O(k)의 시간 복잡도를 가진다.
  - 여기서 k는 name 배열의 길이이다.
  - 이 단계는 주로 k의 크기에만 영향을 받기 때문에, k의 크기가 작을 때는 무시할 수 있다.
    - k가 n이나 m과 비교했을 때 상대적으로 매우 작아서 전체적인 성능에 거의 영향을 미치지 않기 때문이다.
- 사진별 추억 점수 계산 단계
  - 각 사진에 등장하는 인물의 그리움 점수를 계산하는 작업이 O(n * m)이다.
  - n은 photo 배열의 길이 (사진의 수)
  - m은 각 사진에 등장하는 인물의 수 이다.
  - 각 사진마다 등장하는 모든 인물을 순회하면서 그리움 점수를 HashMap에서 조회하기 때문에, 각 인물 조회는 O(1)이다.
  - 결과적으로, 이 부분이 `O(n * m)`의 시간 복잡도를 가진다.
- 최종 시간 복잡도
  - 전체 코드의 시간 복잡도는 `O(k + n * m)`이다.
  - 하지만 k는 그리움 점수를 기록한 사람의 수로, 일반적으로 `n * m`에 비해 상대적으로 작을 수 있기 때문에 주로 `O(n * m)`로 간주할 수 있다.








