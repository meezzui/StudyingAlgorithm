### 문제🧐
지민이는 다양한 크기의 정사각형 모양 돗자리를 가지고 공원에 소풍을 나왔습니다. 공원에는 이미 돗자리를 깔고 여가를 즐기는 사람들이 많아 지민이가 깔 수 있는 가장 큰 돗자리가 어떤 건지 확인하려 합니다. 예를 들어 지민이가 가지고 있는 돗자리의 한 변 길이가 5, 3, 2 세 종류이고, 사람들이 다음과 같이 앉아 있다면 지민이가 깔 수 있는 가장 큰 돗자리는 3x3 크기입니다.
지민이가 가진 돗자리들의 한 변의 길이들이 담긴 정수 리스트 mats, 현재 공원의 자리 배치도를 의미하는 2차원 문자열 리스트 park가 주어질 때 지민이가 깔 수 있는 가장 큰 돗자리의 한 변 길이를 return 하도록 solution 함수를 완성해 주세요. 아무런 돗자리도 깔 수 없는 경우 -1을 return합니다.
```
[제한 사항]

1 ≤ mats의 길이 ≤ 10
  1 ≤ mats의 원소 ≤ 20
  mats는 중복된 원소를 가지지 않습니다.
1 ≤ park의 길이 ≤ 50
  1 ≤ park[i]의 길이 ≤ 50
  park[i][j]의 원소는 문자열입니다.
  park[i][j]에 돗자리를 깐 사람이 없다면 "-1", 사람이 있다면 알파벳 한 글자로 된 값을 갖습니다.
```
```
[입출력 예시]

mats	[5,3,2]
park [["A", "A", "-1", "B", "B", "B", "B", "-1"], ["A", "A", "-1", "B", "B", "B", "B", "-1"], ["-1", "-1", "-1", "-1", "-1", "-1", "-1", "-1"], ["D", "D", "-1", "-1", "-1", "-1", "E", "-1"], ["D", "D", "-1", "-1", "-1", "-1", "-1", "F"], ["D", "D", "-1", "-1", "-1", "-1", "E", "-1"]]
result 3
```
### 문제 해결 아이디어 💡
- 민이가 공원의 배치도에서 사람이 없는 영역을 찾아 가장 큰 돗자리를 놓을 수 있는지 확인하는 문제이다.
- 주어진 돗자리 크기와 공원의 상태를 탐색하면서, 돗자리를 깔 수 있는 가장 큰 영역을 찾아야 한다.
  - 돗자리 크기 정렬: 큰 돗자리부터 확인하는 것이 유리하므로, mats 리스트를 내림차순으로 정렬
  - 돗자리를 놓을 수 있는지 확인: 각 돗자리 크기에 대해 공원의 각 위치를 탐색하여 그 위치를 시작점으로 돗자리를 놓을 수 있는지 확인
  - 돗자리 확인 로직: 시작 좌표 (i, j)에서 size x size 크기의 돗자리가 놓일 수 있는지 확인. 모든 해당 영역이 -1이어야 돗자리를 놓을 수 있다.
  - 가장 큰 돗자리 찾기: 탐색을 마친 후 가장 큰 돗자리를 찾고, 없다면 -1을 반환

### 문제 풀이📝
- canPlaceMat 함수
  - park: 공원 배치도를 나타내는 2차원 배열. startX, startY: 돗자리를 놓기 시작할 좌표. size: 돗자리의 한 변의 길이
  - 주어진 startX, startY 좌표에서 size x size 크기의 돗자리를 놓을 수 있는지 확인합니다. 돗자리가 공원의 경계를 벗어나거나, 사람이 있는 공간을 침범하면 false를 반환. 모두 빈 공간("-1")이면 true를 반환
- solution 함수: 돗자리 크기 배열 mats를 내림차순으로 정렬한 후, 가장 큰 돗자리부터 순차적으로 공원의 각 위치에서 놓을 수 있는지 확인
놓을 수 있는 돗자리를 찾으면 그 크기를 반환하고, 찾지 못하면 -1을 반환
- main 함수: 테스트 케이스를 실행하여 결과를 확인. 주어진 예시에서 가장 큰 돗자리는 3x3 크기이므로, 결과는 3
```java
import java.util.*;

public class Solution {
    
    // 주어진 좌표에서 size 크기의 돗자리를 놓을 수 있는지 확인하는 함수
    public static boolean canPlaceMat(String[][] park, int startX, int startY, int size) {
        // 돗자리가 공원을 넘어가는지 확인
        if (startX + size > park.length || startY + size > park[0].length) { // 공원의 세로 또는 가로의 길이를 넘으면 돗자리가 공원을 벗어남
            return false;
        }
        
        // 돗자리를 놓을 공간이 모두 빈 공간("-1")인지 확인
        for (int i = startX; i < startX + size; i++) {
            for (int j = startY; j < startY + size; j++) {
                if (!park[i][j].equals("-1")) {
                    return false; // 만약 빈 공간이 아니라면(-1이 아닌 다른 값이 있으면) false를 반환
                }
            }
        }
        return true; // 모든 공간이 빈 공간이면 돗자리를 놓을 수 있으므로 true를 반환
    }
    
    // 돗자리를 놓을 수 있는 가장 큰 돗자리 크기를 찾는 함수
    public static int solution(int[] mats, String[][] park) {
        // 돗자리 크기를 오름차순 정렬 (큰 것부터 탐색하기 위해)
        Arrays.sort(mats);
        
        // 큰 돗자리부터 확인하기 위해 역순 탐색
        for (int k = mats.length - 1; k >= 0; k--) {
            int matSize = mats[k]; // matSize는 현재 확인 중인 돗자리의 한 변 길이를 의미한다.
            
            // 공원의 모든 좌표에 대해 돗자리를 놓을 수 있는지 확인
            for (int i = 0; i < park.length; i++) {
                for (int j = 0; j < park[0].length; j++) {
                    // 해당 위치에서 matSize 크기의 돗자리를 놓을 수 있으면 그 크기를 반환
                    if (canPlaceMat(park, i, j, matSize)) {
                        return matSize;
                    }
                }
            }
        }
        
        // 돗자리를 놓을 수 있는 공간이 없으면 -1 반환
        return -1;
    }
    
    public static void main(String[] args) {
        // 테스트 케이스
        int[] mats = {5, 3, 2};
        String[][] park = {
            {"A", "-1", "-1", "-1", "-1"},
            {"-1", "-1", "-1", "-1", "-1"},
            {"-1", "-1", "B", "-1", "-1"},
            {"-1", "-1", "-1", "-1", "-1"},
            {"-1", "-1", "-1", "-1", "-1"}
        };
        
        // 결과 출력
        System.out.println(solution(mats, park));  // 예상 결과: 2
    }
}

```
