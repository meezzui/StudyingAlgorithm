### List 와 ArrayList 차이점
- List = 인터페이스
- ArrayList = 클래스
```
ArrayList <Object> arr = new ArrayList <>();
List <Object> arr = new ArrayList <>();
```
- 위 두 코드의 차이점은??
  - 2가지 모두 같은 결과가 나온다. 하지만 List를 사용해 ArrayList를 생성하는 것은 유연성에서 효과적이다.
  - 예를들어, String 타입,Integer타입 등 다양한 타입을 지원하고 싶은 경우가 있다. 이때 타입을 Generic(제너릭)으로 지정해주면 편리하고 효율적이게 사용할 수 있다.
    - Generic은 클래스 내부에서 지정하는 것이 아닌 외부에서 사용자에 의해 지정되는 것을 의미한다. 다시말해 특정 타입을 미리 지정해주는 것이 아닌 필요에 의해 지정할 수 있도록 하는 일반(Generic) 타입이다.
- 즉, 인스턴스의 형 변환을 통해 내부 디테일과 메모리 함축에서 이점과 성능을 개선시킬 수 있다.

### 인스턴스의 형 변환 이점
```
List<String> arr = new ArrayList <>();

코드 설명 : 여기서 List<String>은 List 인터페이스 타입으로 선언되었고, ArrayList<String>으로 초기화되었다.
          즉, arr은 ArrayList의 인스턴스지만, List 타입의 참조를 사용하여 접근하고 있다.
```
- 유연성
  - List 인터페이스로 코드를 작성하면, 내부 구현을 쉽게 교체할 수 있다.
  - 예를 들어, ArrayList에서 LinkedList로 구현체를 변경하고 싶을 때 코드에서 List 인터페이스를 사용하고 있으면 한 줄만 수정하면 된다.
  - 이로 인해 코드의 유연성과 확장성이 크게 향상된다.
  - `ist<String> arr = new LinkedList<>();`
- 인터페이스 기반 프로그래밍
  - 상위 인터페이스(List)로 코드를 작성하면, 더 일반화된 코드를 만들 수 있다.
  - 메서드나 클래스에서 매개변수나 반환값으로 ArrayList 대신 List를 사용하면 다양한 구현체와 호환되도록 작성할 수 있다.
  - 예를 들어, ArrayList, LinkedList, Vector 등의 구현체 모두를 사용할 수 있게 된다.
- 메모리 함축
  - ArrayList의 경우 내부적으로 동적 배열을 사용하여 요소를 저장한다.
  - 배열이 꽉 차면 더 큰 배열을 만들어 데이터를 복사하는 방식으로 크기를 조정한다. 이 과정에서 배열이 과도하게 클 경우 메모리 낭비가 발생할 수 있다.
  - 이러한 문제를 줄이기 위해 형 변환을 통해 특정 구현체를 결정하기 전에 최적의 구현체를 선택할 수 있다. 예를 들어, 데이터의 삽입/삭제가 빈번하다면 `LinkedList`가 더 적합할 수 있고, 인덱스로 자주 접근한다면 `ArrayList`가 더 나을 수 있다.  

🌈 결과적으로 상위 인터페이스로 선언하고, 하위 구현체로 초기화하는 방식은 유지보수성과 성능 최적화를 동시에 제공하는 유연한 프로그래밍 방법이다.



